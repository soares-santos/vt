static char *EVENTS_C="\n\n#ifdef TEST\n#include <math.h>\n#define EVFILTRTN _FilterEvents\n#define NSHAPE 1\n#define NREGION 1\n#define _X_ X\n#define _Y_ Y\n#define FILTER ((circle(g,1,1,1,_X_,_Y_,1,2,3)))\n#define EVSIZE 4\n#define X *((short *)(eptr+0))\n#define Y *((short *)(eptr+2))\n#include \"regions.h\"\n#endif\n\nstatic char __abuf[EVSIZE+1];\nstatic char *acopy(void *s, int n)\n{\n  memset(__abuf, 0, n+1);\n  memmove(__abuf, s, n);\n  return __abuf;\n}\n\nvoid *EVFILTRTN(void *tg, char *ebuf, int ne, int esize, int *rbuf)\n{\n  int i, j;\n  int  *rptr;\n  char *eptr;\n  Scan scan, tscan;\n  GFilt g = (GFilt)tg;\n\n  \n  \n  eptr = ebuf;\n\n  if( !g ){\n    g = (GFilt)calloc(1, sizeof(GFiltRec));\n#if NSHAPE\n    \n    g->nshapes = NSHAPE;\n    g->maxshapes = (NSHAPE*(XSNO+1))+1;\n    g->shapes = (Shape)calloc(g->maxshapes, sizeof(ShapeRec));\n#endif\n#ifdef EVSECT\n    \n    g->evsect = EVSECT;\n    sscanf(g->evsect, \"%d %d %d %d %d\",\n	   &g->xmin, &g->xmax, &g->ymin, &g->ymax, &g->block);\n    \n    g->x0 = 1;\n    g->y0 = 1;\n    g->x1 = (g->xmax-g->xmin)/g->block+1;\n    g->y1 = (g->ymax-g->ymin)/g->block+1;\n    \n    g->ybuf = (int *)calloc(g->y1+1, sizeof(int));\n    g->x0s = (int *)calloc(g->y1+1, sizeof(int));\n    g->x1s = (int *)calloc(g->y1+1, sizeof(int));\n    \n    for(i=0; i<=g->y1; i++) g->x0s[i]  = g->x0;\n    for(i=0; i<=g->y1; i++) g->x1s[i]  = g->x1;\n    \n    if( NMASK ){\n      g->nmask = NMASK; \n      g->maskdim = MASKDIM;\n      g->masks = _masks;\n    }\n    \n    if( eptr ) FINIT;\n    \n    g->tlminx = TLMINX;\n    g->tlminy = TLMINY;\n    g->usebinsiz = USEBINSIZ;\n    if( BINSIZX > 0.0 )\n      g->binsizx = BINSIZX;\n    else\n      g->binsizx = 1.0;\n    if( BINSIZY > 0.0 )\n      g->binsizy = BINSIZY;\n    else\n      g->binsizy = 1.0;\n    g->tloff =  TLOFF;\n#endif\n  }\n\n  \n  if( !ebuf && !rbuf && (ne<0) ){\n#if NSHAPE\n    \n    for(i=0; i<g->maxshapes; i++){\n      if( g->shapes[i].scanlist ){\n	for(j=0; j<g->y1; j++){\n	  if( g->shapes[i].scanlist[j] ){\n	    for(scan=g->shapes[i].scanlist[j]; scan; ){\n	      tscan = scan->next;\n	      if( scan ) free(scan);\n	      scan = tscan;\n	    }\n	  }\n	}\n	if( g->shapes[i].scanlist ) free(g->shapes[i].scanlist);\n      }\n      if( g->shapes[i].pts ) free(g->shapes[i].pts);\n      if( g->shapes[i].xv ) free(g->shapes[i].xv);\n    }\n    if( g->masks )  free(g->masks);\n    if( g->shapes ) free(g->shapes);\n    if( g->ybuf )   free(g->ybuf);\n    if( g->x0s )    free(g->x0s);\n    if( g->x1s )    free(g->x1s);\n    if( g )         free(g);\n#endif\n    return NULL;\n  }\n  else{\n    \n    for(rptr=rbuf, eptr=ebuf; ne--; rptr++, eptr += esize){\n      g->rid = 0;\n      *rptr = ((FILTER) ? (g->rid ? g->rid : -1) : 0);\n    }\n    return (void *)g;\n  }\n}\n\nint main(int argc, char **argv)\n{\n  char *ebuf, *etop;\n  int  *rbuf;\n  int get, got;\n  int n;\n  void *g=NULL;\n\n  \n  while( read(0, &get, sizeof(int)) >0 ){\n    ebuf = (char *)calloc(get, sizeof(char));\n    for(n=0, etop=ebuf; get>0; etop += got, get -= got){\n      if( (got=read(0, etop, get)) <=0 )\n	break;\n      n += got;\n    }\n    n /= EVSIZE;\n    \n    rbuf = (int *)calloc(n, sizeof(int));\n    \n    g = EVFILTRTN(g, ebuf, n, EVSIZE, rbuf);\n    \n    got = n*sizeof(int);\n    write(1, &got, sizeof(int));\n    write(1, rbuf, got);\n    if( ebuf) free(ebuf);\n    if( rbuf ) free(rbuf);\n  }\n  EVFILTRTN(g, NULL, -1, 0, NULL);\n  unlink(argv[0]);\n  return 0;\n}\n";
